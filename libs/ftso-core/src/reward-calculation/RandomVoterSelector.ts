import { ethers } from "ethers";
import { Address } from "../voting-types";
import Web3 from "web3";
import { encodeParameters } from "web3-eth-abi";

const web3 = new Web3();
/**
 * Random voter selector for finalization reward eligibility calculation.
 */
export class RandomVoterSelector {
  thresholds: bigint[];
  totalWeight: bigint;
  voters: Address[];
  weights: bigint[];
  defaultThresholdBIPS: number;

  constructor(voters: Address[], weights: bigint[], defaultThresholdBIPS?: number) {
    if (voters.length !== weights.length) {
      throw new Error("voters and weights must have the same length");
    }
    this.voters = [...voters];
    this.weights = [...weights];
    this.totalWeight = 0n;
    this.thresholds = [];
    for (const weight of weights) {
      this.thresholds.push(this.totalWeight);
      this.totalWeight += weight;
    }
    this.defaultThresholdBIPS = defaultThresholdBIPS || 0;

    // We limit the threshold to 5000 BIPS to avoid long running loops
    // In practice it will be used with around 1000 BIPS or lower.
    if (this.defaultThresholdBIPS <= 0 || this.defaultThresholdBIPS > 5000) {
      throw new Error("Default threshold must be between 0 and 10000 BIPS");
    }
  }

  /**
   * Selects a random voter based provided random number.
   * Random number is encoded as 32-bytes 0x prefixed hex string.
   * @returns the selected voter
   */
  public selectVoterIndex(randomNumber: string): number {
    if (!randomNumber.startsWith("0x")) {
      throw new Error("Random number must be 0x-prefixed hex string");
    }
    const randomWeight = BigInt(randomNumber) % this.totalWeight;
    const index = this.binarySearch(randomWeight);
    return index;
  }

  /**
   * Searches for the highest index of the threshold that is less than or equal to the value.
   * Binary search is used.
   */
  public binarySearch(value: bigint): number {
    if (value < 0n || value > this.totalWeight) {
      throw new Error("Value must be between 0 and total weight");
    }
    let left = 0;
    let right = this.thresholds.length - 1;
    let mid = 0;
    if (this.thresholds[right] <= value) {
      return right;
    }
    while (left < right) {
      mid = Math.floor((left + right) / 2);
      if (this.thresholds[mid] < value) {
        left = mid + 1;
      } else if (this.thresholds[mid] > value) {
        right = mid;
      } else {
        return mid;
      }
    }
    return left - 1;
  }

  /**
   * Based on initial seed and threshold in BIPS it selects a random set of voters with weight
   * greater than or equal to the threshold. The threshold is expressed in BIPS (basis points)
   * of total voter weight.
   * If the threshold is 0 it randomly selects on voter, with probability proportional to its weight.
   */
  public randomSelectThresholdWeightVoters(randomSeed: string, providedThresholdBIPS?: number): Address[] {
    // We limit the threshold to 5000 BIPS to avoid long running loops
    // In practice it will be used with around 1000 BIPS or lower.
    const thresholdBIPS = providedThresholdBIPS ?? this.defaultThresholdBIPS;
    if (!thresholdBIPS || thresholdBIPS <= 0 || thresholdBIPS > 5000) {
      throw new Error("Threshold must be > 0 and <= 5000 BIPS");
    }
    let selectedWeight = 0n;
    const thresholdWeight = (this.totalWeight * BigInt(thresholdBIPS)) / 10000n;
    let currentSeed = randomSeed;
    const selectedVoters = new Set<Address>();

    // If threshold weight is not too big, the loop should end quickly
    while (selectedWeight < thresholdWeight) {
      const index = this.selectVoterIndex(currentSeed);
      const selectedAddress = this.voters[index];
      if (!selectedVoters.has(selectedAddress)) {
        selectedVoters.add(selectedAddress);
        selectedWeight += this.weights[index];
      }
      currentSeed = ethers.keccak256(currentSeed);
    }
    return [...selectedVoters];
  }

  public randomNumberSequence(initialSeed: string, length: number): string[] {
    const sequence = [];
    let currentSeed = initialSeed;
    for (let i = 0; i < length; i++) {
      sequence.push(currentSeed);
      currentSeed = ethers.keccak256(currentSeed);
    }
    return sequence;
  }

  /**
   * Initial seed for random voter selection for finalization reward calculation.
   * Initial seed is calculated as a hash of protocol ID and voting round ID.
   * The seed is used for the first random. Next randoms are generated by
   */
  public static initialHashSeed(rewardEpochSeed: string, protocolId: number, votingRoundId: number): string {
    return Web3.utils.soliditySha3(encodeParameters(["bytes32", "uint256", "uint256"], [rewardEpochSeed, protocolId, votingRoundId]))!;
  }

  /**
   * Given protocol ID, voting round ID and address, it checks if the address is in the selection set.
   * If thresholdBIPS is not provided, the default threshold is used.
   */
  public inSelectionSet(rewardEpochSeed: string, protocolId: number, votingRoundId: number, address: string, thresholdBIPS?: number): boolean {
    const initialSeed = RandomVoterSelector.initialHashSeed(rewardEpochSeed, protocolId, votingRoundId);
    let result = this.randomSelectThresholdWeightVoters(initialSeed, thresholdBIPS);
    for (const anAddress of result) {
      if (anAddress.toLowerCase() === address.toLowerCase()) {
        return true;
      }
    }
    return false;
  }
}
